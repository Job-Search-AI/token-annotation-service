<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>토큰 태깅 서비스 (NER)</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Inter 폰트 설정 */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap");
      body {
        font-family: "Inter", sans-serif;
        background-color: #f7f9fb;
      }
      /* 태깅된 토큰 색상 매핑 */
      .bg-B-JOB {
        background-color: #6366f1;
      } /* Indigo */
      .bg-I-JOB {
        background-color: #818cf8;
      }
      .bg-B-CAR {
        background-color: #22c55e;
      } /* Green */
      .bg-I-CAR {
        background-color: #4ade80;
      }
      .bg-B-EDU {
        background-color: #f97316;
      } /* Orange */
      .bg-I-EDU {
        background-color: #fb923c;
      }
      .bg-B-LOC {
        background-color: #06b6d4;
      } /* Cyan */
      .bg-I-LOC {
        background-color: #22d3ee;
      }
      .bg-O {
        background-color: #94a3b8;
      } /* Slate */

      .token-tag {
        color: white;
        padding: 4px 8px;
        margin: 2px;
        border-radius: 6px;
        transition: transform 0.1s, box-shadow 0.1s;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        font-weight: 500;
      }

      .token-tag:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .current-token-wrapper {
        min-height: 150px; /* 레이아웃 안정성 확보 */
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <!-- 메인 컨테이너 -->
    <div id="app" class="max-w-6xl mx-auto">
      <header class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-gray-800">
          토큰 태깅 서비스 (NER 태깅)
        </h1>
        <p class="text-gray-500">
          각 토큰에 '직무', '경력', '학력', '지역' 또는 'O(기타)' 태그를
          할당하세요.
        </p>
      </header>

      <!-- 1. 입력 설정 및 진행 상황 영역 -->
      <section
        id="setup-section"
        class="bg-white p-6 rounded-xl shadow-lg mb-8"
      >
        <!-- FLEX CONTAINER: 제목과 버튼을 같은 층에 가로로 배치 -->
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-semibold text-gray-700">
            입력 모델 및 문장 설정
          </h2>

          <!-- 토크나이저 ID 수정 버튼 (⚙️ 이모티콘만, 배경/모서리 변경) -->
          <button
            id="open-tokenizer-modal-btn"
            title="토크나이저 ID 수정"
            class="bg-gray-200 text-gray-800 w-10 h-10 rounded-lg text-lg font-medium hover:bg-gray-300 transition shadow-sm border border-gray-300 flex items-center justify-center"
          >
            ⚙️
          </button>
        </div>
        <!-- FLEX CONTAINER 끝 -->

        <div class="flex flex-col md:flex-row gap-4 mb-4">
          <textarea
            id="input-sentences"
            class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition"
            rows="3"
            placeholder="한 줄에 하나의 문장을 입력하세요. (예: 신입 고졸 프론트엔드 개발자 서울 공고 알려줘.)"
          ></textarea>
          <button
            id="start-btn"
            class="bg-indigo-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-indigo-700 transition duration-150 shadow-md whitespace-nowrap"
          >
            작업 시작 / 재시작
          </button>
        </div>

        <!-- 토크나이저 로딩 상태 및 진행 상황 표시 (레이아웃 분리) -->
        <div id="progress-container" class="mt-2">
          <!-- 1. 로딩 상태/모델 ID -->
          <p id="progress-status-line" class="text-sm text-gray-600">
            토크나이저 로딩 전... (klue/bert-base)
          </p>
          <!-- 2. 문장 카운트 (새 줄) -->
          <p
            id="progress-count-line"
            class="text-sm text-gray-500 mt-0.5 font-medium"
          >
            현재 진행: 0 / 0 문장
          </p>
        </div>
      </section>

      <!-- 2. 토큰 태깅 영역 (작업 중일 때만 표시) -->
      <section
        id="annotation-section"
        class="bg-white p-8 rounded-xl shadow-lg mb-8 hidden"
      >
        <h2 class="text-xl font-semibold mb-6 text-gray-700">토큰 태깅</h2>

        <!-- 현재 토큰 표시 -->
        <div
          class="current-token-wrapper flex flex-col items-center justify-center mb-8"
        >
          <!-- 변경: h-24, flex, items-center, justify-center를 추가하여 높이를 고정하고 텍스트를 중앙에 배치 -->
          <span
            class="text-6xl font-extrabold text-indigo-700 h-24 flex items-center justify-center"
            id="current-token"
          ></span>
          <!-- 변경: h-5를 추가하여 설명 텍스트 영역의 높이를 고정 -->
          <p class="text-sm text-gray-400 mt-2 h-5">({}번째 토큰)</p>
        </div>

        <!-- 태그 할당 버튼 (숫자 단축키 추가) -->
        <div
          id="tag-buttons"
          class="grid grid-cols-2 md:grid-cols-5 gap-3 max-w-2xl mx-auto"
        >
          <button
            data-tag="JOB"
            class="tag-btn bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 rounded-lg shadow-md transition duration-150"
          >
            1. 직무 (JOB)
          </button>
          <button
            data-tag="CAR"
            class="tag-btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 rounded-lg shadow-md transition duration-150"
          >
            2. 경력 (CAR)
          </button>
          <button
            data-tag="EDU"
            class="tag-btn bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 rounded-lg shadow-md transition duration-150"
          >
            3. 학력 (EDU)
          </button>
          <button
            data-tag="LOC"
            class="tag-btn bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 rounded-lg shadow-md transition duration-150"
          >
            4. 지역 (LOC)
          </button>
          <!-- 'O (기타)' 버튼을 'X (O 태깅)'으로 변경 -->
          <button
            data-tag="O"
            class="tag-btn bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 rounded-lg shadow-md transition duration-150"
          >
            5. X (O 태깅)
          </button>
        </div>

        <!-- 문장 완료/다음 문장 버튼 -->
        <div class="text-center mt-6">
          <!-- 변경: 'hidden'을 'invisible opacity-0'로 교체하여 공간은 유지하되 시각적으로만 숨깁니다. -->
          <button
            id="next-input-btn"
            class="bg-blue-600 text-white px-8 py-3 rounded-lg font-medium hover:bg-blue-700 transition duration-150 shadow-lg invisible opacity-0"
          >
            다음 문장으로 →
          </button>
        </div>
      </section>

      <!-- 3. 실시간 진행 상황 및 수정 영역 -->
      <section
        id="status-section"
        class="bg-white p-6 rounded-xl shadow-lg mb-8 hidden"
      >
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          실시간 태깅 상태 (클릭하여 수정)
        </h2>
        <p class="text-sm text-gray-500 mb-3">
          <span class="font-bold text-gray-700">현재 문장:</span>
          <span id="current-sentence-display"></span>
        </p>

        <!-- 태그 목록 표시 -->
        <div
          id="token-list"
          class="flex flex-wrap gap-2 p-3 border border-gray-200 rounded-lg min-h-12 bg-gray-50"
        >
          <p class="text-gray-400 text-sm italic">
            토큰을 할당하면 여기에 표시됩니다.
          </p>
        </div>

        <!-- JSON 결과 실시간 표시 -->
        <h3 class="text-lg font-medium mt-6 mb-2 text-gray-700">
          현재 JSON 결과:
        </h3>
        <pre
          id="current-json-output"
          class="bg-gray-800 text-green-300 p-4 rounded-lg overflow-x-auto text-sm"
        >
{}</pre
        >
      </section>

      <!-- 4. 최종 결과 영역 -->
      <section
        id="final-results-section"
        class="bg-white p-6 rounded-xl shadow-lg mb-8 hidden"
      >
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          최종 결과물 (<span id="final-count">0</span>개 문장 처리 완료)
        </h2>
        <p class="text-gray-600 mb-4">
          현재까지 처리된 모든 입력 문장에 대한 태깅 결과입니다. 아래 JSON을
          복사할 수 있습니다.
        </p>
        <pre
          id="final-json-output"
          class="bg-gray-800 text-yellow-300 p-4 rounded-lg overflow-x-auto text-sm max-h-96"
        >
[]</pre
        >
        <div class="flex gap-3 mt-4">
          <button
            id="copy-json-btn"
            class="bg-purple-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-purple-700 transition duration-150 shadow-md"
          >
            JSON 복사
          </button>
          <button
            id="save-to-storage-btn"
            class="bg-green-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-green-700 transition duration-150 shadow-md"
          >
            💾 로컬스토리지에 저장
          </button>
        </div>
      </section>

      <!-- 5. 저장된 작업 목록 섹션 -->
      <section
        id="saved-data-section"
        class="bg-white p-6 rounded-xl shadow-lg mb-8"
      >
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          저장된 작업 목록
        </h2>
        <p class="text-gray-600 mb-4">
          로컬스토리지에 저장된 작업들입니다. 불러와서 이어서 작업할 수
          있습니다.
        </p>
        <div
          id="saved-data-list"
          class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
        >
          <!-- 저장된 데이터 카드들이 여기에 동적으로 추가됩니다 -->
        </div>
      </section>

      <!-- 커스텀 모달 (경고/확인용) -->
      <div
        id="custom-modal"
        class="fixed inset-0 bg-black bg-opacity-50 z-50 items-center justify-center hidden"
      >
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4">
          <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800">
            알림
          </h3>
          <div id="modal-content-container">
            <!-- Dynamic content: message or input goes here -->
            <p class="text-gray-700 mb-4">내용</p>
          </div>
          <div class="flex justify-end space-x-3">
            <button
              id="modal-close-btn"
              class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400 transition"
            >
              닫기
            </button>
            <button
              id="modal-action-btn"
              class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition hidden"
            >
              확인
            </button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      // Hugging Face Transformers.js 라이브러리에서 AutoTokenizer를 직접 가져옵니다.
      import { AutoTokenizer } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.4";

      // 앱 상태 변수
      let globalState = {
        inputs: [], // 모든 입력 문장
        currentInputIndex: 0, // 현재 처리 중인 문장 인덱스
        currentTokenIndex: 0, // 현재 처리 중인 토큰 인덱스
        currentTokens: [], // 현재 문장의 토큰 배열
        currentTokenTags: [], // 현재 문장의 태그 배열
        allResults: [], // 모든 완료된 결과
        isEditingTokenIndex: -1, // 수정 중인 토큰의 인덱스 (-1이면 수정 아님)
        loadedDataId: null, // 현재 불러온 데이터의 ID (이어서 작업 시 사용)
      };

      // 로컬스토리지 관련 상수
      const STORAGE_KEY = "tokenAnnotationSaves";

      // LLM 토크나이저 상태 변수 (Hugging Face Transformers.js 사용)
      let tokenizer = null;
      let isTokenizerReady = false;
      let loadedModelId = null; // 현재 로드된 모델 ID
      let pendingModelId = "klue/bert-base"; // 사용자가 설정한 (아직 로드되지 않은) ID

      // UI 요소 캐싱
      const elements = {
        inputSentences: document.getElementById("input-sentences"),
        startBtn: document.getElementById("start-btn"),

        // 변경된 요소 ID 반영
        progressStatusLine: document.getElementById("progress-status-line"),
        progressCountLine: document.getElementById("progress-count-line"),

        annotationSection: document.getElementById("annotation-section"),
        statusSection: document.getElementById("status-section"),
        finalResultsSection: document.getElementById("final-results-section"),
        currentToken: document.getElementById("current-token"),
        tokenList: document.getElementById("token-list"),
        currentJsonOutput: document.getElementById("current-json-output"),
        finalJsonOutput: document.getElementById("final-json-output"),
        nextInputBtn: document.getElementById("next-input-btn"),
        tagButtons: document.querySelectorAll(".tag-btn"),
        currentSentenceDisplay: document.getElementById(
          "current-sentence-display"
        ),
        copyJsonBtn: document.getElementById("copy-json-btn"),
        finalCount: document.getElementById("final-count"),

        // 새 요소
        openTokenizerModalBtn: document.getElementById(
          "open-tokenizer-modal-btn"
        ),
        saveToStorageBtn: document.getElementById("save-to-storage-btn"),
        savedDataList: document.getElementById("saved-data-list"),

        // 모달 관련 요소 (수정됨)
        modal: document.getElementById("custom-modal"),
        modalTitle: document.getElementById("modal-title"),
        modalContentContainer: document.getElementById(
          "modal-content-container"
        ),
        modalCloseBtn: document.getElementById("modal-close-btn"),
        modalActionBtn: document.getElementById("modal-action-btn"),
      };

      // --- 유틸리티 함수 ---

      // --- 로컬스토리지 관련 함수 ---

      /**
       * 로컬스토리지에서 모든 저장된 데이터 가져오기
       * @returns {Array} 저장된 데이터 배열
       */
      const getAllSavedData = () => {
        try {
          const data = localStorage.getItem(STORAGE_KEY);
          if (!data) return [];
          const parsed = JSON.parse(data);
          // 최신순으로 정렬 (timestamp 기준)
          return parsed.sort(
            (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
          );
        } catch (error) {
          console.error("로컬스토리지 데이터 읽기 오류:", error);
          return [];
        }
      };

      /**
       * 로컬스토리지에 데이터 저장
       * @param {string} name - 저장할 데이터 이름
       * @returns {boolean} 저장 성공 여부
       */
      const saveToLocalStorage = (name) => {
        try {
          if (!name || name.trim() === "") {
            showModal("경고", "저장 이름을 입력해주세요.");
            return false;
          }

          if (name.length > 50) {
            showModal("경고", "저장 이름은 50자 이내로 입력해주세요.");
            return false;
          }

          if (globalState.allResults.length === 0) {
            showModal(
              "경고",
              "저장할 결과가 없습니다. 먼저 태깅 작업을 완료해주세요."
            );
            return false;
          }

          const allData = getAllSavedData();

          // 같은 이름이 있는지 확인
          const existingIndex = allData.findIndex((item) => item.name === name);

          const newData = {
            id: globalState.loadedDataId || Date.now().toString(),
            name: name.trim(),
            timestamp: new Date().toISOString(),
            modelId: loadedModelId || pendingModelId,
            results: JSON.parse(JSON.stringify(globalState.allResults)),
          };

          if (existingIndex !== -1) {
            // 덮어쓰기
            allData[existingIndex] = newData;
          } else {
            // 새로 추가
            allData.push(newData);
          }

          localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
          globalState.loadedDataId = newData.id; // 저장 후 ID 업데이트

          renderSavedDataList();
          showModal(
            "저장 완료",
            `"${name}" 작업이 로컬스토리지에 저장되었습니다.`
          );
          return true;
        } catch (error) {
          console.error("로컬스토리지 저장 오류:", error);
          if (error.name === "QuotaExceededError") {
            showModal(
              "저장 실패",
              "로컬스토리지 용량이 부족합니다. 일부 데이터를 삭제해주세요."
            );
          } else {
            showModal("저장 실패", "데이터 저장 중 오류가 발생했습니다.");
          }
          return false;
        }
      };

      /**
       * 로컬스토리지에서 데이터 불러오기
       * @param {string} id - 불러올 데이터 ID
       */
      const loadFromLocalStorage = (id) => {
        try {
          const allData = getAllSavedData();
          const data = allData.find((item) => item.id === id);

          if (!data) {
            showModal("오류", "해당 데이터를 찾을 수 없습니다.");
            return;
          }

          // 데이터 로드
          globalState.allResults = JSON.parse(JSON.stringify(data.results));
          globalState.loadedDataId = data.id;
          pendingModelId = data.modelId;

          // 현재 작업 중인 내용 초기화
          globalState.inputs = [];
          globalState.currentInputIndex = 0;
          globalState.currentTokens = [];
          globalState.currentTokenTags = [];
          globalState.currentTokenIndex = 0;

          // 입력창 비우기
          elements.inputSentences.value = "";

          renderUI();
          showModal("불러오기 완료", `"${data.name}" 프로젝트를 불러왔습니다.`);
        } catch (error) {
          console.error("로컬스토리지 불러오기 오류:", error);
          showModal(
            "불러오기 실패",
            "데이터를 불러오는 중 오류가 발생했습니다."
          );
        }
      };

      /**
       * 로컬스토리지에서 데이터 삭제
       * @param {string} id - 삭제할 데이터 ID
       */
      const deleteFromLocalStorage = (id) => {
        try {
          const allData = getAllSavedData();
          const filtered = allData.filter((item) => item.id !== id);

          localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));
          renderSavedDataList();
          showModal("삭제 완료", "작업이 삭제되었습니다.");
        } catch (error) {
          console.error("로컬스토리지 삭제 오류:", error);
          showModal("삭제 실패", "데이터 삭제 중 오류가 발생했습니다.");
        }
      };

      /**
       * 저장된 데이터 목록 UI 렌더링
       */
      const renderSavedDataList = () => {
        const allData = getAllSavedData();

        if (allData.length === 0) {
          elements.savedDataList.innerHTML = `
            <div class="col-span-full text-center py-8">
              <p class="text-gray-400 text-lg">저장된 작업이 없습니다.</p>
              <p class="text-gray-500 text-sm mt-2">태깅 작업을 완료한 후 "로컬스토리지에 저장" 버튼을 클릭하세요.</p>
            </div>
          `;
          return;
        }

        elements.savedDataList.innerHTML = allData
          .map((data) => {
            const date = new Date(data.timestamp);
            const formattedDate = date.toLocaleString("ko-KR", {
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
            });

            return `
            <div class="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow bg-gray-50">
              <h3 class="font-bold text-lg text-gray-800 mb-2 truncate" title="${
                data.name
              }">
                ${data.name}
              </h3>
              <div class="text-sm text-gray-600 space-y-1 mb-3">
                <p>📅 ${formattedDate}</p>
                <p>📝 ${data.results.length}개 문장</p>
                <p class="truncate" title="${data.modelId}">🤖 ${
              data.modelId
            }</p>
              </div>
              <div class="flex gap-2">
                <button
                  onclick="handleLoadData('${data.id}')"
                  class="flex-1 bg-blue-500 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-blue-600 transition"
                >
                  불러오기
                </button>
                <button
                  onclick="handleDeleteData('${data.id}', '${data.name.replace(
              /'/g,
              "\\'"
            )}')"
                  class="bg-red-500 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-red-600 transition"
                >
                  삭제
                </button>
              </div>
            </div>
          `;
          })
          .join("");
      };

      /**
       * 저장 이름 입력 모달 표시
       */
      const showSaveModal = () => {
        elements.modalTitle.textContent = "작업 저장";

        // 기본 이름 생성 - 불러온 데이터가 있으면 그 이름 사용
        let defaultName;
        if (globalState.loadedDataId) {
          const allData = getAllSavedData();
          const loadedData = allData.find(
            (item) => item.id === globalState.loadedDataId
          );
          defaultName = loadedData ? loadedData.name : `새 프로젝트`;
        } else {
          defaultName = `새 프로젝트`;
        }

        elements.modalContentContainer.innerHTML = `
          <p class="text-gray-700 mb-3 text-sm">
            저장할 작업의 이름을 입력하세요.
          </p>
          <input 
            type="text" 
            id="modal-save-name-input" 
            value="${defaultName}" 
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 transition" 
            placeholder="작업 이름"
            maxlength="50">
          <p class="text-sm text-gray-500 mt-2">같은 이름이 있으면 덮어씁니다.</p>
        `;

        elements.modalActionBtn.classList.remove("hidden");
        elements.modalActionBtn.textContent = "저장";
        elements.modalActionBtn.className =
          "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition";
        elements.modalCloseBtn.textContent = "취소";

        elements.modalActionBtn.onclick = () => {
          const inputElement = document.getElementById("modal-save-name-input");
          const name = inputElement.value.trim();

          if (saveToLocalStorage(name)) {
            elements.modal.classList.add("hidden");
            elements.modal.classList.remove("flex");
          }
        };

        elements.modalCloseBtn.onclick = () => {
          elements.modal.classList.add("hidden");
          elements.modal.classList.remove("flex");
        };

        elements.modal.classList.remove("hidden");
        elements.modal.classList.add("flex");

        setTimeout(() => {
          const input = document.getElementById("modal-save-name-input");
          if (input) {
            input.focus();
            input.select();
          }
        }, 100);
      };

      // 전역 함수로 노출 (HTML onclick에서 사용)
      window.handleLoadData = (id) => {
        // 현재 작업 중인 내용이 있는지 확인
        if (
          globalState.currentTokens.length > 0 ||
          globalState.inputs.length > 0
        ) {
          elements.modalTitle.textContent = "불러오기 확인";
          elements.modalContentContainer.innerHTML = `
            <p class="text-gray-700 mb-4">현재 작업 중인 내용이 있습니다.<br>불러오면 현재 내용이 사라집니다.<br><br>계속하시겠습니까?</p>
          `;
          elements.modalActionBtn.classList.remove("hidden");
          elements.modalActionBtn.textContent = "불러오기";
          elements.modalActionBtn.className =
            "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition";
          elements.modalCloseBtn.textContent = "취소";

          elements.modalActionBtn.onclick = () => {
            loadFromLocalStorage(id);
            elements.modal.classList.add("hidden");
            elements.modal.classList.remove("flex");
          };

          elements.modalCloseBtn.onclick = () => {
            elements.modal.classList.add("hidden");
            elements.modal.classList.remove("flex");
          };

          elements.modal.classList.remove("hidden");
          elements.modal.classList.add("flex");
        } else {
          loadFromLocalStorage(id);
        }
      };

      window.handleDeleteData = (id, name) => {
        elements.modalTitle.textContent = "삭제 확인";
        elements.modalContentContainer.innerHTML = `
          <p class="text-gray-700 mb-4">"${name}" 작업을 삭제하시겠습니까?<br><br>이 작업은 되돌릴 수 없습니다.</p>
        `;
        elements.modalActionBtn.classList.remove("hidden");
        elements.modalActionBtn.textContent = "삭제";
        elements.modalActionBtn.className =
          "bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition";
        elements.modalCloseBtn.textContent = "취소";

        elements.modalActionBtn.onclick = () => {
          deleteFromLocalStorage(id);
          elements.modal.classList.add("hidden");
          elements.modal.classList.remove("flex");
        };

        elements.modalCloseBtn.onclick = () => {
          elements.modal.classList.add("hidden");
          elements.modal.classList.remove("flex");
        };

        elements.modal.classList.remove("hidden");
        elements.modal.classList.add("flex");
      };

      // --- 기존 유틸리티 함수 ---

      /**
       * 커스텀 알림 모달 표시 (간단한 알림용)
       * @param {string} title - 모달 제목
       * @param {string} message - 모달 메시지 (HTML 가능)
       */
      const showModal = (title, message) => {
        // 내부 컨텐츠 초기화 및 메시지 삽입
        elements.modalContentContainer.innerHTML = `<p id="modal-message" class="text-gray-700 mb-4">${message}</p>`;

        elements.modalTitle.textContent = title;
        elements.modalActionBtn.classList.add("hidden"); // 액션 버튼 숨김
        elements.modalCloseBtn.textContent = "확인"; // 닫기 버튼 텍스트 변경

        elements.modal.classList.remove("hidden");
        elements.modal.classList.add("flex");

        // 모달을 닫는 기본 핸들러 설정
        elements.modalCloseBtn.onclick = () => {
          elements.modal.classList.add("hidden");
          elements.modal.classList.remove("flex");
        };
        elements.modalActionBtn.onclick = null; // 액션 초기화
      };

      /**
       * 토크나이저 설정 모달 표시 및 입력 처리
       */
      const openTokenizerConfigModal = () => {
        elements.modalTitle.textContent = "Hugging Face 토크나이저 ID 설정";

        // Input 필드와 메시지를 포함하는 동적 콘텐츠 생성
        elements.modalContentContainer.innerHTML = `
                <p class="text-gray-700 mb-3 text-sm">
                    토큰화에 사용할 Hugging Face 모델 ID를 입력하세요. (예: <span class="font-mono text-indigo-600">klue/bert-base</span>)
                </p>
                <input type="text" id="modal-tokenizer-input" value="${pendingModelId}" 
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition" 
                       placeholder="모델 ID">
                <p class="text-sm text-gray-500 mt-2">현재 로드된 모델: ${
                  loadedModelId || "없음"
                }</p>
            `;

        // 액션 버튼 표시 및 텍스트/핸들러 설정
        elements.modalActionBtn.classList.remove("hidden");
        elements.modalActionBtn.textContent = "적용";
        elements.modalCloseBtn.textContent = "취소";

        // 적용 버튼 클릭 핸들러
        elements.modalActionBtn.onclick = () => {
          const inputElement = document.getElementById("modal-tokenizer-input");
          const newModelId = inputElement.value.trim();

          if (newModelId) {
            const oldModelId = pendingModelId;
            pendingModelId = newModelId; // 설정 완료
            elements.modal.classList.add("hidden");
            elements.modal.classList.remove("flex");

            // 만약 ID가 변경되었거나 로드된 적이 없다면, 사용자에게 '작업 시작'을 누르라고 알림
            if (newModelId !== loadedModelId && newModelId !== oldModelId) {
              showModal(
                "알림",
                `토크나이저 ID가 <span class="font-bold text-indigo-600">${newModelId}</span>으로 설정되었습니다. <br>변경 사항을 적용하려면 **'작업 시작 / 재시작'** 버튼을 눌러주세요.`
              );
            } else {
              showModal(
                "알림",
                `토크나이저 ID가 <span class="font-bold text-indigo-600">${newModelId}</span>으로 설정되었습니다.`
              );
            }
            renderUI(); // UI 업데이트를 통해 pendingModelId를 반영
          } else {
            // 입력이 비어있으면 경고
            showModal("경고", "토크나이저 ID를 입력해주세요.");
          }
        };

        // 취소 버튼 클릭 핸들러 (모달 닫기)
        elements.modalCloseBtn.onclick = () => {
          elements.modal.classList.add("hidden");
          elements.modal.classList.remove("flex");
        };

        elements.modal.classList.remove("hidden");
        elements.modal.classList.add("flex");
        // 모달 열릴 때 input에 포커스
        setTimeout(() => {
          document.getElementById("modal-tokenizer-input")?.focus();
        }, 100);
      };

      // 태그에 따른 배경 색상 클래스 반환
      const getTagColorClass = (tag) => {
        if (!tag) return "bg-gray-300 text-gray-700";
        const baseTag = tag.replace(/^[BI]-/, "");
        return `bg-${tag} text-white`;
      };

      /**
       * 토큰을 LLM 토크나이저 기준으로 분리
       * @param {string} sentence - 토큰화할 문장
       * @returns {string[]} 토큰 리스트
       */
      const tokenize = (sentence) => {
        if (!tokenizer) {
          console.error("토크나이저가 아직 준비되지 않았습니다.");
          return [];
        }

        // AutoTokenizer의 tokenize 메서드를 사용하여 토큰화 수행
        const tokens = tokenizer.tokenize(sentence);

        // WordPiece 기반 토크나이저의 ## 접두사 제거
        const filteredTokens = tokens
          .map((token) => token.replace(/^##/, ""))
          .filter((t) => t.length > 0); // 빈 문자열 토큰 제거

        return filteredTokens;
      };

      // --- 토크나이저 로딩 로직 ---
      /**
       * 지정된 모델 ID로 토크나이저를 초기화하고 로드합니다.
       * @param {string} modelId - Hugging Face 모델 ID (예: 'klue/bert-base')
       */
      const initializeTokenizer = async (modelId) => {
        if (!modelId) {
          showModal("경고", "토크나이저 ID를 입력해야 합니다.");
          isTokenizerReady = false;
          loadedModelId = null;
          elements.progressStatusLine.innerHTML = `<span class="text-red-500 font-bold">모델 ID가 필요합니다.</span> (${pendingModelId})`;
          return;
        }

        isTokenizerReady = false;
        loadedModelId = null;
        elements.progressStatusLine.innerHTML = `토크나이저 로딩 중... (${modelId}) <span class="text-indigo-500 font-bold">최초 로딩 시 수십 초가 소요될 수 있습니다.</span>`;

        try {
          tokenizer = await AutoTokenizer.from_pretrained(modelId);

          isTokenizerReady = true;
          loadedModelId = modelId;

          // 로딩 완료 시 메시지 업데이트는 renderUI에서 처리
          renderUI();
        } catch (error) {
          console.error("토크나이저 로딩 중 오류 발생:", error);
          elements.progressStatusLine.innerHTML = `<span class="text-red-500 font-bold">토크나이저 로딩 실패.</span> ID: ${modelId}`;
          showModal(
            "오류",
            `토크나이저 모델 (${modelId}) 로딩에 실패했습니다. ID를 확인하고 콘솔을 참조하세요.`
          );
        }
      };

      // --- UI 및 상태 관리 로직 ---

      /**
       * 최종 JSON 결과를 원하는 형식(label 배열을 한 줄로)으로 포맷합니다.
       */
      const formatFinalJson = (prettyPrint) => {
        const displayResults = JSON.parse(
          JSON.stringify(globalState.allResults)
        );

        displayResults.forEach((result) => {
          if (result.label && Array.isArray(result.label)) {
            result.label = JSON.stringify(result.label);
          }
        });

        let jsonString = JSON.stringify(
          displayResults,
          null,
          prettyPrint ? 2 : 0
        );

        // 문자열로 변환된 label 배열을 다시 JSON 배열 형태로 복원합니다.
        jsonString = jsonString.replace(
          /("label": )"(\[.*?\])"/gs,
          (match, p1, p2) => {
            const unescapedLabels = p2.replace(/\\"/g, '"');
            return `${p1}${unescapedLabels}`;
          }
        );

        return jsonString;
      };

      /**
       * 토큰에 태그를 할당하고 B-I-O 규칙을 적용합니다.
       */
      const tagToken = (entityType) => {
        const index =
          globalState.isEditingTokenIndex !== -1
            ? globalState.isEditingTokenIndex
            : globalState.currentTokenIndex;

        if (index >= globalState.currentTokens.length) {
          return;
        }

        let newTag = "";

        if (entityType === "O") {
          newTag = "O";
        } else {
          let prevTag =
            index > 0 ? globalState.currentTokenTags[index - 1] : null;
          const prevEntityType = prevTag ? prevTag.replace(/^[BI]-/, "") : null;

          if (prevEntityType === entityType) {
            newTag = `I-${entityType}`;
          } else {
            newTag = `B-${entityType}`;
          }
        }

        globalState.currentTokenTags[index] = newTag;

        if (globalState.isEditingTokenIndex !== -1) {
          globalState.isEditingTokenIndex = -1;
        } else {
          globalState.currentTokenIndex++;
        }

        renderUI();
      };

      /**
       * 현재 문장의 JSON 결과 생성 (model_id 제거됨)
       */
      const generateCurrentJson = () => {
        const input = globalState.inputs[globalState.currentInputIndex] || "";
        const labels = globalState.currentTokenTags;

        if (labels.length === 0) return {};

        return {
          input: input,
          // model_id는 사용자 요청에 따라 제거됨
          label: labels,
        };
      };

      // 현재 토큰 표시 및 버튼 활성화/비활성화
      const updateAnnotationUI = () => {
        const totalTokens = globalState.currentTokens.length;
        const index =
          globalState.isEditingTokenIndex !== -1
            ? globalState.isEditingTokenIndex
            : globalState.currentTokenIndex;

        if (index < totalTokens) {
          elements.currentToken.textContent = globalState.currentTokens[index];
          elements.currentToken
            .closest(".current-token-wrapper")
            .querySelector("p").textContent = `(${index + 1}번째 토큰)`;

          elements.nextInputBtn.classList.add("invisible", "opacity-0");
          elements.nextInputBtn.classList.remove("visible", "opacity-100");
          elements.tagButtons.forEach((btn) => (btn.disabled = false));
        } else {
          elements.currentToken.textContent = "✅ 문장 태깅 완료";
          elements.currentToken
            .closest(".current-token-wrapper")
            .querySelector("p").textContent =
            "다음 문장으로 넘어가거나 수정을 확인하세요.";

          elements.nextInputBtn.classList.remove("invisible", "opacity-0");
          elements.nextInputBtn.classList.add("visible", "opacity-100");
          elements.tagButtons.forEach((btn) => (btn.disabled = true));
        }
      };

      // 토큰 목록 (수정 가능 영역) 렌더링
      const renderTokenList = () => {
        elements.tokenList.innerHTML = "";
        if (globalState.currentTokens.length === 0) {
          elements.tokenList.innerHTML =
            '<p class="text-gray-400 text-sm italic">토큰을 할당하면 여기에 표시됩니다.</p>';
          return;
        }

        globalState.currentTokens.forEach((token, idx) => {
          const tag = globalState.currentTokenTags[idx];
          const tagText = tag || "?";
          const colorClass = getTagColorClass(tag);

          const tokenElement = document.createElement("div");
          tokenElement.className = `token-tag ${colorClass}`;

          tokenElement.innerHTML = `
                    <span class="font-semibold">${token}</span>
                    <span class="ml-2 opacity-75 text-xs">
                        (<span class="inline-block min-w-[32px] text-center">${tagText}</span>)
                    </span>
                `;

          tokenElement.dataset.index = idx;

          // 클릭 시 수정 모드로 전환
          tokenElement.onclick = () => enterEditMode(idx);

          elements.tokenList.appendChild(tokenElement);
        });
      };

      // 수정 모드 진입
      const enterEditMode = (index) => {
        globalState.isEditingTokenIndex = index;
        console.log(
          `[${globalState.currentTokens[index]}] 토큰 수정 모드 진입. 아래 태깅 버튼을 다시 눌러 수정하세요.`
        );

        updateAnnotationUI();
        renderUI();
      };

      // 전체 UI 렌더링 (상태 변경 시 호출)
      const renderUI = () => {
        const totalInputs = globalState.inputs.length;
        const currentInputIndex = globalState.currentInputIndex;
        const hasResults = globalState.allResults.length > 0;

        // 현재 입력 문장들을 모두 처리했는지 확인
        const isCurrentBatchFinished =
          currentInputIndex >= totalInputs && totalInputs > 0;

        console.log(
          "[renderUI] totalInputs:",
          totalInputs,
          "currentInputIndex:",
          currentInputIndex,
          "isCurrentBatchFinished:",
          isCurrentBatchFinished
        );

        // 1. 설정 및 진행 상황 업데이트
        elements.inputSentences.value = globalState.inputs.join("\n");
        elements.finalCount.textContent = globalState.allResults.length;

        const modelDisplay = loadedModelId || pendingModelId;
        const progressCountText = `${currentInputIndex} / ${totalInputs} 문장`; // 현재 처리 중인 인덱스 기준

        // 1-1. 진행 상태 라인 업데이트
        let statusText = "";
        if (isTokenizerReady) {
          statusText = `<span class="font-bold text-green-500">토크나이저 로딩 완료!</span> (${modelDisplay})`;
        } else if (loadedModelId) {
          statusText = `토크나이저 로딩 중... (${modelDisplay})`;
        } else {
          statusText = `토크나이저 로딩 전... (${modelDisplay})`;
        }
        elements.progressStatusLine.innerHTML = statusText;

        // 1-2. 문장 카운트 라인 업데이트
        elements.progressCountLine.textContent = `현재 진행: ${progressCountText}`;

        // 2. 섹션 표시/숨김 관리
        // 현재 배치의 작업이 완료되었거나 입력이 없으면 태깅 섹션 숨김
        if (isCurrentBatchFinished || totalInputs === 0) {
          elements.annotationSection.classList.add("hidden");
          elements.statusSection.classList.add("hidden");
          elements.currentJsonOutput.textContent = isCurrentBatchFinished
            ? "작업 완료."
            : "{}";
        } else {
          elements.annotationSection.classList.remove("hidden");
          elements.statusSection.classList.remove("hidden");

          // 3. 현재 문장 정보 업데이트
          elements.currentSentenceDisplay.textContent =
            globalState.inputs[globalState.currentInputIndex];

          // 4. 태깅 UI 업데이트
          updateAnnotationUI();
          renderTokenList();
          elements.currentJsonOutput.textContent = JSON.stringify(
            generateCurrentJson(),
            null,
            2
          );
        }

        if (hasResults) {
          elements.finalResultsSection.classList.remove("hidden");
          elements.finalJsonOutput.textContent = formatFinalJson(true);
        } else {
          elements.finalResultsSection.classList.add("hidden");
        }

        // 저장된 데이터 목록도 렌더링
        renderSavedDataList();
      };

      // --- 이벤트 핸들러 ---

      // 토크나이저 설정 모달 열기 버튼 핸들러
      elements.openTokenizerModalBtn.onclick = openTokenizerConfigModal;

      // 작업 시작 버튼 핸들러 (async로 변경)
      elements.startBtn.onclick = async () => {
        const rawInputs = elements.inputSentences.value
          .split("\n")
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        const newModelId = pendingModelId; // 설정된 ID 사용

        console.log("[작업 시작] 입력 문장 수:", rawInputs.length);
        console.log("[작업 시작] 불러온 데이터 ID:", globalState.loadedDataId);
        console.log("[작업 시작] 기존 결과 수:", globalState.allResults.length);

        if (!newModelId) {
          showModal("경고", "토크나이저 ID를 설정해주세요.");
          return;
        }

        // 토크나이저 ID가 변경되었거나 아직 로드되지 않은 경우 재로딩
        if (newModelId !== loadedModelId || !isTokenizerReady) {
          await initializeTokenizer(newModelId);
        }

        if (!isTokenizerReady) {
          return;
        }

        if (rawInputs.length === 0) {
          showModal("경고", "태깅할 문장을 한 줄 이상 입력해주세요.");
          return;
        }

        // 새 작업 시작 시 상태 설정
        globalState.inputs = rawInputs;
        globalState.currentInputIndex = 0;
        // 주의: allResults는 초기화하지 않음 (불러온 데이터가 있으면 유지)
        // 새로 시작하는 경우에만 초기화
        if (!globalState.loadedDataId) {
          globalState.allResults = [];
          console.log("[작업 시작] 새 작업 - allResults 초기화");
        } else {
          console.log(
            "[작업 시작] 이어서 작업 - allResults 유지 (" +
              globalState.allResults.length +
              "개)"
          );
        }

        // 첫 문장으로 이동
        await moveToNextInput(true);
      };

      // 태그 버튼 클릭 핸들러 (tagToken 함수 호출)
      elements.tagButtons.forEach((button) => {
        button.onclick = (e) => {
          const entityType = e.target.dataset.tag;
          if (!entityType) return;

          if (
            globalState.currentTokens.length === 0 ||
            (globalState.currentTokenIndex >=
              globalState.currentTokens.length &&
              globalState.isEditingTokenIndex === -1)
          ) {
            console.warn(
              "현재 처리할 토큰이 없습니다. 다음 문장으로 넘어가거나 작업을 시작해주세요."
            );
            return;
          }

          tagToken(entityType);
        };
      });

      // 다음 문장 버튼 핸들러 (async로 변경)
      elements.nextInputBtn.onclick = async () => {
        await moveToNextInput(false);
      };

      elements.copyJsonBtn.onclick = () => {
        const jsonText = formatFinalJson(true);
        try {
          // execCommand를 사용하여 클립보드에 복사
          const textarea = document.createElement("textarea");
          textarea.value = jsonText;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
          showModal("복사 완료", "최종 JSON 결과가 클립보드에 복사되었습니다.");
        } catch (err) {
          console.error("복사 오류:", err);
          showModal(
            "복사 실패",
            "클립보드 복사에 실패했습니다. 콘솔을 확인해주세요."
          );
        }
      };

      // 저장 버튼 이벤트 핸들러
      elements.saveToStorageBtn.onclick = () => {
        if (globalState.allResults.length === 0) {
          showModal(
            "경고",
            "저장할 결과가 없습니다. 먼저 태깅 작업을 완료해주세요."
          );
          return;
        }
        showSaveModal();
      };

      // 다음 문장으로 이동 및 토큰/태그 초기화 (async로 변경)
      const moveToNextInput = async (isStart) => {
        const totalInputs = globalState.inputs.length;
        const currentIdx = globalState.currentInputIndex;

        if (!isStart && currentIdx < totalInputs) {
          globalState.allResults.push(generateCurrentJson());
          globalState.currentInputIndex++;
        }

        const nextIndex = globalState.currentInputIndex;

        if (nextIndex < totalInputs) {
          const nextSentence = globalState.inputs[nextIndex];

          globalState.currentTokens = tokenize(nextSentence);

          globalState.currentTokenTags = new Array(
            globalState.currentTokens.length
          ).fill(null);
          globalState.currentTokenIndex = 0;

          if (globalState.currentTokens.length === 0) {
            showModal(
              "경고",
              `"${nextSentence.substring(
                0,
                20
              )}..." 문장의 토큰화 결과가 비어있습니다. 다음 문장으로 넘어갑니다.`
            );
            // model_id 제거
            globalState.allResults.push({
              input: nextSentence,
              label: ["Error: Tokenization failed or resulted in empty array."],
            }); // 오류 문장도 결과에 추가
            globalState.currentInputIndex++;

            if (globalState.currentInputIndex < totalInputs) {
              // 토큰화 결과가 비어있으면 다음 문장으로 재귀 호출하여 즉시 넘어감
              await moveToNextInput(true);
            }
            return;
          }
        }

        if (globalState.currentInputIndex >= totalInputs) {
          globalState.currentTokens = [];
          globalState.currentTokenTags = [];
        }

        renderUI();
      };

      // --- 키보드 이벤트 핸들러 추가 ---
      document.addEventListener("keydown", (e) => {
        const key = e.key;
        let buttonIndex = -1;
        const isInputFocused =
          document.activeElement.tagName === "TEXTAREA" ||
          document.activeElement.tagName === "INPUT";

        // 1. 모달 닫기 (Enter 키)
        if (!elements.modal.classList.contains("hidden") && e.key === "Enter") {
          // 토크나이저 설정 모달의 입력창이 포커스된 상태에서 Enter를 누르면 '적용' 버튼 클릭
          if (
            document.getElementById("modal-tokenizer-input") ===
            document.activeElement
          ) {
            e.preventDefault();
            elements.modalActionBtn.click();
            return;
          }
          // 저장 모달의 입력창이 포커스된 상태에서 Enter를 누르면 '저장' 버튼 클릭
          else if (
            document.getElementById("modal-save-name-input") ===
            document.activeElement
          ) {
            e.preventDefault();
            elements.modalActionBtn.click();
            return;
          }
          // 일반 알림 모달일 경우 '확인' 버튼 클릭
          else {
            e.preventDefault();
            elements.modalCloseBtn.click();
            return;
          }
        }

        // 2. 문장 완료 및 다음 문장으로 이동 (Enter 키)
        if (
          key === "Enter" &&
          elements.nextInputBtn.classList.contains("visible") &&
          !isInputFocused
        ) {
          e.preventDefault();
          elements.nextInputBtn.click();
          return;
        }

        // 3. 이전 토큰으로 되돌리기 (Backspace 키)
        if (key === "Backspace") {
          if (
            !elements.annotationSection.classList.contains("hidden") &&
            !isInputFocused
          ) {
            e.preventDefault();

            let newIndex = globalState.currentTokenIndex;

            if (newIndex === globalState.currentTokens.length && newIndex > 0) {
              newIndex--;
            } else if (newIndex > 0) {
              newIndex--;
            }

            if (newIndex !== globalState.currentTokenIndex) {
              globalState.currentTokenIndex = newIndex;

              if (globalState.currentTokenTags[newIndex] !== undefined) {
                globalState.currentTokenTags[newIndex] = null;
              }

              globalState.isEditingTokenIndex = -1;

              renderUI();
            }
            return;
          }
        }

        // 4. 태그 할당 (1~5 키)
        if (key >= "1" && key <= "5") {
          buttonIndex = parseInt(key) - 1;
        }

        if (buttonIndex !== -1 && buttonIndex < elements.tagButtons.length) {
          if (
            elements.annotationSection.classList.contains("hidden") ||
            isInputFocused
          ) {
            return;
          }

          const targetButton = elements.tagButtons[buttonIndex];

          if (targetButton && !targetButton.disabled) {
            e.preventDefault();

            // 시각적 피드백
            targetButton.classList.add(
              "ring-4",
              "ring-offset-2",
              "ring-opacity-50",
              "ring-indigo-300"
            );

            setTimeout(() => {
              targetButton.classList.remove(
                "ring-4",
                "ring-offset-2",
                "ring-opacity-50",
                "ring-indigo-300"
              );
            }, 100);

            const entityType = targetButton.dataset.tag;
            tagToken(entityType);
          }
        }
      });
      // --- 키보드 이벤트 핸들러 끝 ---

      // 애플리케이션 시작 시 토크나이저 로딩 시작 (pendingModelId의 기본값을 사용)
      window.onload = () => {
        initializeTokenizer(pendingModelId);
        renderSavedDataList(); // 저장된 데이터 목록 렌더링
      };
    </script>
  </body>
</html>
